package controller;

import dto.ErrorResponse;
import exception.FriendshipRequestExistsException;
import exception.FriendshipRequestNotFoundException;
import exception.InvalidInputException;
import exception.UserNotFoundException;
import model.Friendship;
import model.User;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.web.bind.annotation.*;
import pubsub.IEventManager;
import repository.FriendshipRepository;
import repository.UserRepository;

import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

/**
 * Simplified controller for handling friend-related operations using exception-based error handling.
 */
@RestController
@RequestMapping("/api/simple/friends")
@CrossOrigin(origins = "*") // Adjust as needed for your frontend
public class SimplifiedFriendController {

    @Autowired
    private FriendshipRepository friendshipRepository;

    @Autowired
    private UserRepository userRepository;

    @Autowired
    private IEventManager eventManager;

    /**
     * Sends a friend request from the authenticated user to a target user.
     * The request is stored with a PENDING status.
     *
     * @param request A map containing the "targetUsername" of the user to send the request to.
     * @return A {@link ResponseEntity} indicating the success or failure of the friend request.
     *         Returns 200 OK on success, 401 Unauthorized if the user is not authenticated,
     *         or 400 Bad Request for invalid input or if a friendship already exists/is pending.
     */
    @PostMapping("/request")
    public ResponseEntity<Map<String, String>> sendFriendRequest(@RequestBody Map<String, String> request) {
        String authenticatedUsername = getCurrentUsername();
        if (authenticatedUsername == null) {
            throw new UserNotFoundException("User not authenticated");
        }

        String targetUsername = request.get("targetUsername");
        if (targetUsername == null || targetUsername.equals(authenticatedUsername)) {
            throw new InvalidInputException("Invalid target username");
        }

        // Get users by username
        User sender = userRepository.findByUsername(authenticatedUsername).orElse(null);
        User target = userRepository.findByUsername(targetUsername).orElse(null);

        if (sender == null || target == null) {
            throw new UserNotFoundException("User not found");
        }

        // Check if friendship already exists
        if (friendshipRepository.existsBetweenUsers(sender.getPlayerId(), target.getPlayerId())) {
            throw new FriendshipRequestExistsException("Friendship already exists or request is pending");
        }

        // Create new friendship request (PENDING status)
        Friendship friendship = new Friendship(sender.getPlayerId(), target.getPlayerId(), Friendship.Status.PENDING);
        friendshipRepository.save(friendship);

        // Send real-time notification to the target user
        String notificationChannel = "user-notifications:" + target.getPlayerId();
        String notification = "FRIEND_REQUEST:" + sender.getPlayerId() + ":" + sender.getUsername();
        eventManager.publish(notificationChannel, notification);

        Map<String, String> response = new HashMap<>();
        response.put("message", "Friend request sent successfully");
        return ResponseEntity.ok(response);
    }

    /**
     * Accepts a pending friend request.
     * The authenticated user must be the recipient of the request.
     *
     * @param request A map containing the "senderUsername" of the user whose request is being accepted.
     * @return A {@link ResponseEntity} indicating the success or failure of accepting the request.
     *         Returns 200 OK on success, 401 Unauthorized if the user is not authenticated,
     *         or 400 Bad Request for invalid input or if no pending request is found.
     */
    @PostMapping("/accept")
    public ResponseEntity<Map<String, String>> acceptFriendRequest(@RequestBody Map<String, String> request) {
        String authenticatedUsername = getCurrentUsername();
        if (authenticatedUsername == null) {
            throw new UserNotFoundException("User not authenticated");
        }

        String senderUsername = request.get("senderUsername");
        if (senderUsername == null) {
            throw new InvalidInputException("Sender username is required");
        }

        // Get users by username
        User receiver = userRepository.findByUsername(authenticatedUsername).orElse(null);
        User sender = userRepository.findByUsername(senderUsername).orElse(null);

        if (receiver == null || sender == null) {
            throw new UserNotFoundException("User not found");
        }

        // Find the pending friendship request
        Friendship friendship = friendshipRepository.findByUsers(sender.getPlayerId(), receiver.getPlayerId())
                .orElse(null);

        if (friendship == null || friendship.getStatus() != Friendship.Status.PENDING) {
            throw new FriendshipRequestNotFoundException("No pending friend request found");
        }

        // Ensure that the authenticated user is the one who received the request
        if (!friendship.getUserBId().equals(receiver.getPlayerId())) {
            throw new InvalidInputException("You cannot accept a request you sent");
        }

        // Update the friendship status to ACCEPTED
        friendship.setStatus(Friendship.Status.ACCEPTED);
        friendshipRepository.save(friendship);

        // Send real-time notification to the sender that the request was accepted
        String notificationChannel = "user-notifications:" + sender.getPlayerId();
        String notification = "FRIEND_REQUEST_ACCEPTED:" + receiver.getPlayerId() + ":" + receiver.getUsername();
        eventManager.publish(notificationChannel, notification);

        Map<String, String> response = new HashMap<>();
        response.put("message", "Friend request accepted successfully");
        return ResponseEntity.ok(response);
    }

    /**
     * Rejects a pending friend request.
     * The authenticated user must be the recipient of the request.
     *
     * @param request A map containing the "senderUsername" of the user whose request is being rejected.
     * @return A {@link ResponseEntity} indicating the success or failure of rejecting the request.
     *         Returns 200 OK on success, 401 Unauthorized if the user is not authenticated,
     *         or 400 Bad Request for invalid input or if no pending request is found.
     */
    @PostMapping("/reject")
    public ResponseEntity<Map<String, String>> rejectFriendRequest(@RequestBody Map<String, String> request) {
        String authenticatedUsername = getCurrentUsername();
        if (authenticatedUsername == null) {
            throw new UserNotFoundException("User not authenticated");
        }

        String senderUsername = request.get("senderUsername");
        if (senderUsername == null) {
            throw new InvalidInputException("Sender username is required");
        }

        // Get users by username
        User receiver = userRepository.findByUsername(authenticatedUsername).orElse(null);
        User sender = userRepository.findByUsername(senderUsername).orElse(null);

        if (receiver == null || sender == null) {
            throw new UserNotFoundException("User not found");
        }

        // Find the pending friendship request
        Friendship friendship = friendshipRepository.findByUsers(sender.getPlayerId(), receiver.getPlayerId())
                .orElse(null);

        if (friendship == null || friendship.getStatus() != Friendship.Status.PENDING) {
            throw new FriendshipRequestNotFoundException("No pending friend request found");
        }

        // Ensure that the authenticated user is the one who received the request
        if (!friendship.getUserBId().equals(receiver.getPlayerId())) {
            throw new InvalidInputException("You cannot reject a request you sent");
        }

        // Update the friendship status to REJECTED
        friendship.setStatus(Friendship.Status.REJECTED);
        friendshipRepository.save(friendship);

        // Send real-time notification to the sender that the request was rejected
        String notificationChannel = "user-notifications:" + sender.getPlayerId();
        String notification = "FRIEND_REQUEST_REJECTED:" + receiver.getPlayerId() + ":" + receiver.getUsername();
        eventManager.publish(notificationChannel, notification);

        Map<String, String> response = new HashMap<>();
        response.put("message", "Friend request rejected successfully");
        return ResponseEntity.ok(response);
    }

    /**
     * Retrieves a list of all accepted friends for the authenticated user.
     *
     * @return A {@link ResponseEntity} containing a map with a list of friends and their count.
     *         Each friend is represented by a map containing their playerId and username.
     *         Returns 200 OK on success, 401 Unauthorized if the user is not authenticated,
     *         or 400 Bad Request if the authenticated user is not found.
     */
    @GetMapping
    public ResponseEntity<Map<String, Object>> getFriends() {
        String authenticatedUsername = getCurrentUsername();
        if (authenticatedUsername == null) {
            throw new UserNotFoundException("User not authenticated");
        }

        User currentUser = userRepository.findByUsername(authenticatedUsername).orElse(null);
        if (currentUser == null) {
            throw new UserNotFoundException("User not found");
        }

        // Get all accepted friendships for the user
        List<Friendship> friendships = friendshipRepository.findFriendsByUserId(currentUser.getPlayerId());

        // Get the friend User objects
        List<Map<String, String>> friends = friendships.stream().map(friendship -> {
            String friendPlayerId = friendship.getOtherUser(currentUser.getPlayerId());
            User friend = userRepository.findByPlayerId(friendPlayerId).orElse(null);
            
            Map<String, String> friendInfo = new HashMap<>();
            friendInfo.put("playerId", friendPlayerId);
            friendInfo.put("username", friend != null ? friend.getUsername() : "Unknown");
            return friendInfo;
        }).collect(Collectors.toList());

        Map<String, Object> response = new HashMap<>();
        response.put("friends", friends);
        response.put("count", friends.size());
        return ResponseEntity.ok(response);
    }

    /**
     * Retrieves a list of pending friend requests received by the authenticated user.
     *
     * @return A {@link ResponseEntity} containing a map with a list of pending requests and their count.
     *         Each request is represented by a map containing the sender's playerId and username.
     *         Returns 200 OK on success, 401 Unauthorized if the user is not authenticated,
     *         or 400 Bad Request if the authenticated user is not found.
     */
    @GetMapping("/requests")
    public ResponseEntity<Map<String, Object>> getFriendRequests() {
        String authenticatedUsername = getCurrentUsername();
        if (authenticatedUsername == null) {
            throw new UserNotFoundException("User not authenticated");
        }

        User currentUser = userRepository.findByUsername(authenticatedUsername).orElse(null);
        if (currentUser == null) {
            throw new UserNotFoundException("User not found");
        }

        // Get all pending friend requests sent to the current user
        List<Friendship> pendingRequests = friendshipRepository.findByUserBIdAndStatus(
                currentUser.getPlayerId(), Friendship.Status.PENDING);

        // Get the sender User objects
        List<Map<String, String>> requests = pendingRequests.stream().map(friendship -> {
            User sender = userRepository.findByPlayerId(friendship.getUserAId()).orElse(null);
            
            Map<String, String> requestInfo = new HashMap<>();
            requestInfo.put("senderPlayerId", friendship.getUserAId());
            requestInfo.put("senderUsername", sender != null ? sender.getUsername() : "Unknown");
            return requestInfo;
        }).collect(Collectors.toList());

        Map<String, Object> response = new HashMap<>();
        response.put("requests", requests);
        response.put("count", requests.size());
        return ResponseEntity.ok(response);
    }

    /**
     * Helper method to retrieve the username of the currently authenticated user.
     *
     * @return The username of the authenticated user, or {@code null} if no user is authenticated
     *         or if the authenticated user is an anonymous user.
     */
    private String getCurrentUsername() {
        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
        if (authentication != null && authentication.isAuthenticated() && 
            !"anonymousUser".equals(authentication.getName())) {
            return authentication.getName();
        }
        return null;
    }
}